#lang scheme
(define a (list (read-line) 1 2 3))
a
(string->number "1234")
(substring "36 55" 0 2)
(substring "36 55" 3)
(string-append "exa " "\n" " mple")
(display " a line \n a new line \n")

(display " 1 1 1 1 1 1 1 1 \n 1 1 1 1 1 1 1 1 \n * 1 1 1 1 1 1 1\n")

(define cookie-list (list 1 1 1 1 1
                          1 1 1 1 1
                          1 1 1 1 1
                          "*" 1 1 1 1))
cookie-list
'( "1" 2 3 4 5)

(floor (inexact->exact (* 100 (random))))

(define row1 (list 1 1 1 1 2))
(define row2 (list 7 1 5 1 1))
(define grid (list row1 row2))
(car grid)
(cadr grid)

;my program 
(define initialize-grid
  (lambda (row column)
    (define per-row
      (lambda (column)
        (if (= 0 column)
            null
            (cons 1 (per-row (- column 1))))))
    (define a-row (per-row column))
    (define (build-grid row)
      (if (= 1 row)
          (list a-row)
          (cons a-row (build-grid (- row 1)))))
    (let ([grid (build-grid row)])
      (cons (cons "*" (cdr (car grid)))
            (sub-list grid 2 (length grid))))))

(define display-grid
  (lambda (grid)
    (let loop ([n (length grid)]
               [grid grid])
      (display "\n")
      (display (car grid))
      (if (= n 1)
          (void)
          (loop (- n 1) (cdr grid))))))
          
(define get-elt
  (lambda (list n)
    (if (= n 1)
        (car list)
        (get-elt (cdr list) (- n 1)))))

(define sub-list
  (lambda (l from to)
    (define sub-list-from
      (lambda (l from-elt)
        (if (= 1 from-elt)
            l
            (sub-list-from (cdr l)
                           (- from-elt 1)))))
    (define sub-list-to
      (lambda (l untill-elt)
        (if (= 0 untill-elt)
            null
            (append (list (car l))
                    (sub-list-to (cdr l) (- untill-elt 1))))))
    (sub-list-to (sub-list-from l from)
                 (- to (- from 1)))))


(define lose?
  (lambda (row column)
    (and (= row 1) (= column 1))))
    
(define eat
  (lambda (row column grid)
    (let ([search-row (get-elt grid row)])
      (let ([search-column (get-elt search-row column)])
        (cond [(equal? search-column 0) false]
              [else true] )))))

(define check-input
  (lambda (row column max-row max-column)
    (cond [(> row max-row) false]
          [(< row 1) false]
          [(> column max-column) false]
          [(< column 1) false]
          [else true] )))

(define update-grid
  (lambda (grid row column)
    (define update-rows
      (lambda (rows nth-elt)
        (let loop ([zero-list (all-zero-list (- (length (car rows)) (- nth-elt 1)))]
                   [rows rows])
          (if (null? rows)
              null
              (append (list (append (sub-list (car rows) 1 (- nth-elt 1))
                                    zero-list))
                      (loop zero-list (cdr rows)))))))
    (define all-zero-list
      (lambda (n)
        (if (= n 0)
            null
            (cons 0 (all-zero-list (- n 1))))))

    (append (sub-list grid 1 (- row 1))
            (update-rows (sub-list grid row (length grid))
                         column))))

(define play-interface
  (lambda ()
    (display "Welcome to Chomp\n")
    (display "Please make your move\n")
    (define play-grid (initialize-grid 4 5))
    (display-grid play-grid)))

(play-interface)
    
    
    
    


  



    
        
                  
          
 

            
            
            
        
 
    

            
        
  